# -*- coding: utf-8 -*-
"""Análise de Pessoas com Deficiência no Ensino Superior - Gráficos

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1abc123...
"""

# Instalação de bibliotecas (se necessário)
#!pip install pandas numpy matplotlib seaborn scikit-learn plotly

# Importação de bibliotecas
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.tree import DecisionTreeClassifier
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# Configuração do estilo dos gráficos
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (12, 8)
plt.rcParams['font.size'] = 12

# ============================================
# 1. DADOS SIMULADOS BASEADOS NO ARTIGO
# ============================================

# Dados de evolução temporal (2011-2019)
anos = list(range(2011, 2020))
alunos_pcd = [45000, 48000, 51000, 53000, 56000, 59000, 62000, 64750, 66750]
total_alunos = [7.0e6, 7.3e6, 7.6e6, 7.9e6, 8.2e6, 8.5e6, 8.8e6, 9.1e6, 9.3e6]

df_evolucao = pd.DataFrame({
    'Ano': anos,
    'Alunos_PCD': alunos_pcd,
    'Total_Alunos': total_alunos
})

df_evolucao['Percentual_PCD'] = (df_evolucao['Alunos_PCD'] / df_evolucao['Total_Alunos']) * 100

# ============================================
# 2. GRÁFICO 1: EVOLUÇÃO DOS ALUNOS COM DEFICIÊNCIA
# ============================================

fig1, ax1 = plt.subplots(2, 1, figsize=(14, 10))

# Subplot 1: Número absoluto
ax1[0].plot(df_evolucao['Ano'], df_evolucao['Alunos_PCD'], 
           marker='o', linewidth=3, markersize=8, color='#2E86AB')
ax1[0].fill_between(df_evolucao['Ano'], df_evolucao['Alunos_PCD'], 
                   alpha=0.3, color='#2E86AB')
ax1[0].set_title('Evolução do Número de Alunos com Deficiência no Ensino Superior (2011-2019)', 
                fontsize=16, fontweight='bold', pad=20)
ax1[0].set_xlabel('Ano', fontsize=14)
ax1[0].set_ylabel('Número de Alunos', fontsize=14)
ax1[0].grid(True, alpha=0.3)
ax1[0].tick_params(axis='both', which='major', labelsize=12)

# Adicionar valores nos pontos
for i, txt in enumerate(df_evolucao['Alunos_PCD']):
    ax1[0].annotate(f'{txt:,}'.replace(',', '.'), 
                   (df_evolucao['Ano'][i], df_evolucao['Alunos_PCD'][i]),
                   textcoords="offset points", xytext=(0,10), 
                   ha='center', fontsize=11)

# Subplot 2: Percentual
ax1[1].plot(df_evolucao['Ano'], df_evolucao['Percentual_PCD'], 
           marker='s', linewidth=3, markersize=8, color='#A23B72')
ax1[1].fill_between(df_evolucao['Ano'], df_evolucao['Percentual_PCD'], 
                   alpha=0.3, color='#A23B72')
ax1[1].set_title('Percentual de Alunos com Deficiência no Total de Matrículas', 
                fontsize=16, fontweight='bold', pad=20)
ax1[1].set_xlabel('Ano', fontsize=14)
ax1[1].set_ylabel('Percentual (%)', fontsize=14)
ax1[1].grid(True, alpha=0.3)
ax1[1].tick_params(axis='both', which='major', labelsize=12)

# Adicionar valores nos pontos
for i, txt in enumerate(df_evolucao['Percentual_PCD']):
    ax1[1].annotate(f'{txt:.3f}%', 
                   (df_evolucao['Ano'][i], df_evolucao['Percentual_PCD'][i]),
                   textcoords="offset points", xytext=(0,10), 
                   ha='center', fontsize=11)

plt.tight_layout()
plt.show()

# ============================================
# 3. GRÁFICO 2: PROJEÇÃO PARA 2030 (REGRESSÃO)
# ============================================

# Simular projeção usando regressão linear simples
from sklearn.linear_model import LinearRegression

# Preparar dados para regressão
X = np.array(anos).reshape(-1, 1)
y = np.array(alunos_pcd)

# Treinar modelo
modelo = LinearRegression()
modelo.fit(X, y)

# Fazer projeção para 2030
anos_futuros = list(range(2011, 2031))
X_futuro = np.array(anos_futuros).reshape(-1, 1)
projecao = modelo.predict(X_futuro)

# Calcular crescimento percentual
crescimento_percentual = ((projecao[-1] - projecao[9]) / projecao[9]) * 100

fig2, ax2 = plt.subplots(figsize=(14, 8))

# Dados históricos
ax2.plot(anos, alunos_pcd, 'o-', linewidth=3, markersize=10, 
        color='#2E86AB', label='Dados Históricos (INEP)', markerfacecolor='white', markeredgewidth=2)

# Projeção
ax2.plot(anos_futuros[9:], projecao[9:], '--', linewidth=3, 
        color='#F18F01', label=f'Projeção até 2030 (+{crescimento_percentual:.1f}%)')

# Área de confiança (simulada)
ax2.fill_between(anos_futuros[9:], 
                projecao[9:] * 0.95, 
                projecao[9:] * 1.05, 
                alpha=0.2, color='#F18F01')

# Destaque para 2030
ax2.plot([2030, 2030], [0, projecao[-1]], ':', color='red', alpha=0.5)
ax2.annotate(f'2030:\n{projecao[-1]:,.0f} alunos'.replace(',', '.'), 
            xy=(2030, projecao[-1]), xytext=(2025, projecao[-1] - 5000),
            arrowprops=dict(arrowstyle='->', color='red'),
            fontsize=12, fontweight='bold', color='red',
            bbox=dict(boxstyle='round,pad=0.5', facecolor='yellow', alpha=0.7))

ax2.set_title('Projeção de Alunos com Deficiência no Ensino Superior até 2030', 
             fontsize=18, fontweight='bold', pad=20)
ax2.set_xlabel('Ano', fontsize=14)
ax2.set_ylabel('Número de Alunos', fontsize=14)
ax2.legend(fontsize=12, loc='upper left')
ax2.grid(True, alpha=0.3)
ax2.set_ylim(bottom=0)

# Adicionar R²
r2 = modelo.score(X, y)
ax2.text(0.02, 0.98, f'R² = {r2:.3f}', transform=ax2.transAxes,
        fontsize=12, verticalalignment='top',
        bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))

plt.tight_layout()
plt.show()

# ============================================
# 4. GRÁFICO 3: DISTRIBUIÇÃO POR TIPO DE DEFICIÊNCIA
# ============================================

# Dados simulados baseados no artigo
tipos_deficiencia = ['Deficiência Física', 'Deficiência Auditiva', 
                     'Deficiência Visual', 'Deficiência Cognitiva', 
                     'Deficiência Múltipla', 'Surdez', 'Baixa Visão', 
                     'Cegueira', 'Superdotação', 'TGD - Autismo']

percentuais = [25, 20, 18, 15, 8, 5, 4, 2, 2, 1]  # Percentuais simulados
cores = ['#2E86AB', '#A23B72', '#F18F01', '#73AB84', '#C14953',
         '#6D98BA', '#D58936', '#8F2D56', '#3C896D', '#9B5DE5']

fig3, (ax3_1, ax3_2) = plt.subplots(1, 2, figsize=(16, 8))

# Gráfico de pizza
wedges, texts, autotexts = ax3_1.pie(percentuais, labels=tipos_deficiencia, 
                                     colors=cores, autopct='%1.1f%%',
                                     startangle=90, explode=[0.1]*len(tipos_deficiencia),
                                     textprops={'fontsize': 10})

# Melhorar legibilidade
for autotext in autotexts:
    autotext.set_color('white')
    autotext.set_fontweight('bold')

ax3_1.set_title('Distribuição de Alunos por Tipo de Deficiência\n(2019)', 
               fontsize=16, fontweight='bold', pad=20)

# Gráfico de barras horizontais
ax3_2.barh(tipos_deficiencia, percentuais, color=cores, edgecolor='black')
ax3_2.set_xlabel('Percentual (%)', fontsize=14)
ax3_2.set_title('Distribuição Percentual por Tipo de Deficiência', 
               fontsize=16, fontweight='bold', pad=20)
ax3_2.invert_yaxis()  # Maior no topo
ax3_2.grid(axis='x', alpha=0.3)

# Adicionar valores nas barras
for i, v in enumerate(percentuais):
    ax3_2.text(v + 0.5, i, f'{v}%', va='center', fontweight='bold', fontsize=11)

plt.tight_layout()
plt.show()

# ============================================
# 5. GRÁFICO 4: CLUSTERING DE IES POR ACESSIBILIDADE
# ============================================

# Simular dados de IES para clustering
np.random.seed(42)
n_ies = 200

# Gerar dados simulados
dados_ies = {
    'Recursos_Acessibilidade': np.random.uniform(0, 100, n_ies),  # % de recursos
    'Alunos_PCD': np.random.randint(0, 500, n_ies),  # Número de alunos
    'Conceito_IGC': np.random.uniform(1, 5, n_ies),  # Conceito IGC
    'Receitas': np.random.uniform(1e6, 1e8, n_ies),  # Receitas em R$
    'Investimentos': np.random.uniform(1e5, 1e7, n_ies)  # Investimentos em R$
}

df_ies = pd.DataFrame(dados_ies)

# Normalizar dados para clustering
scaler = StandardScaler()
dados_normalizados = scaler.fit_transform(df_ies[['Recursos_Acessibilidade', 'Alunos_PCD']])

# Aplicar K-Means
kmeans = KMeans(n_clusters=3, random_state=42)
clusters = kmeans.fit_predict(dados_normalizados)

df_ies['Cluster'] = clusters

# Mapear clusters para nomes descritivos
cluster_names = {
    0: 'Grupo 1: Baixos Recursos',
    1: 'Grupo 2: Recursos Moderados',
    2: 'Grupo 3: Altos Recursos'
}
df_ies['Cluster_Nome'] = df_ies['Cluster'].map(cluster_names)

fig4, ax4 = plt.subplots(figsize=(14, 10))

# Criar scatter plot com cores por cluster
scatter = ax4.scatter(df_ies['Recursos_Acessibilidade'], 
                     df_ies['Alunos_PCD'], 
                     c=df_ies['Cluster'], 
                     cmap='viridis', s=100, 
                     alpha=0.7, edgecolors='black')

# Adicionar centroides
centroids = kmeans.cluster_centers_
centroids_original = scaler.inverse_transform(centroids)
ax4.scatter(centroids_original[:, 0], centroids_original[:, 1],
           c='red', marker='X', s=300, label='Centroides',
           edgecolors='black', linewidth=2)

# Adicionar legendas para clusters
for cluster_num in range(3):
    cluster_data = df_ies[df_ies['Cluster'] == cluster_num]
    mean_recursos = cluster_data['Recursos_Acessibilidade'].mean()
    mean_alunos = cluster_data['Alunos_PCD'].mean()
    
    ax4.annotate(cluster_names[cluster_num],
                xy=(mean_recursos, mean_alunos),
                xytext=(10, 10), textcoords='offset points',
                fontsize=11, fontweight='bold',
                bbox=dict(boxstyle='round,pad=0.5', 
                         facecolor='lightyellow', 
                         alpha=0.8))

# Linhas de referência
ax4.axvline(x=35, color='gray', linestyle='--', alpha=0.5)
ax4.axvline(x=70, color='gray', linestyle='--', alpha=0.5)
ax4.text(17.5, ax4.get_ylim()[1]*0.9, 'Até 35%', fontsize=10, ha='center')
ax4.text(52.5, ax4.get_ylim()[1]*0.9, '35-70%', fontsize=10, ha='center')
ax4.text(85, ax4.get_ylim()[1]*0.9, '>70%', fontsize=10, ha='center')

ax4.set_title('Clustering de IES por Nível de Recursos de Acessibilidade\n(K-Means, 3 clusters)', 
             fontsize=18, fontweight='bold', pad=20)
ax4.set_xlabel('Recursos de Acessibilidade (%)', fontsize=14)
ax4.set_ylabel('Número de Alunos com Deficiência', fontsize=14)
ax4.legend(fontsize=12)
ax4.grid(True, alpha=0.3)

# Adicionar barra de cores
cbar = plt.colorbar(scatter, ax=ax4)
cbar.set_label('Cluster', fontsize=12)

plt.tight_layout()
plt.show()

# ============================================
# 6. GRÁFICO 5: IMPORTÂNCIA DE ATRIBUTOS (ÁRVORE DE DECISÃO)
# ============================================

# Simular dados para árvore de decisão
np.random.seed(42)
n_instancias = 1000

# Features baseadas no artigo
features = [
    'Deficiência Auditiva',
    'Recursos Auditivos',
    'Deficiência Visual',
    'Recursos Visuais',
    'Deficiência Física',
    'Recursos Físicos',
    'Deficiência Cognitiva',
    'Recursos Cognitivos',
    'Categoria_Nacional'  # 1 = federal, 0 = estadual/municipal
]

# Gerar dados simulados
X_simulado = pd.DataFrame({
    'Deficiência Auditiva': np.random.randint(0, 100, n_instancias),
    'Recursos Auditivos': np.random.randint(0, 50, n_instancias),
    'Deficiência Visual': np.random.randint(0, 80, n_instancias),
    'Recursos Visuais': np.random.randint(0, 40, n_instancias),
    'Deficiência Física': np.random.randint(0, 120, n_instancias),
    'Recursos Físicos': np.random.randint(0, 60, n_instancias),
    'Deficiência Cognitiva': np.random.randint(0, 60, n_instancias),
    'Recursos Cognitivos': np.random.randint(0, 20, n_instancias),
    'Categoria_Nacional': np.random.choice([0, 1], n_instancias, p=[0.7, 0.3])
})

# Criar target: 1 se tem alta acessibilidade, 0 se não
y_simulado = ((X_simulado['Recursos Auditivos'] > 25) | 
              (X_simulado['Recursos Visuais'] > 20) |
              (X_simulado['Categoria_Nacional'] == 1)).astype(int)

# Treinar árvore de decisão
dt = DecisionTreeClassifier(max_depth=4, random_state=42)
dt.fit(X_simulado, y_simulado)

# Obter importância das features
importancias = dt.feature_importances_
indices = np.argsort(importancias)[::-1]

fig5, ax5 = plt.subplots(figsize=(14, 10))

# Gráfico de barras horizontais
bars = ax5.barh(range(len(features)), importancias[indices], 
               color=plt.cm.viridis(np.linspace(0.3, 0.9, len(features))))
ax5.set_yticks(range(len(features)))
ax5.set_yticklabels([features[i] for i in indices], fontsize=12)
ax5.invert_yaxis()

# Adicionar valores nas barras
for i, (bar, importancia) in enumerate(zip(bars, importancias[indices])):
    width = bar.get_width()
    ax5.text(width + 0.001, bar.get_y() + bar.get_height()/2,
            f'{importancia:.3f}', ha='left', va='center', 
            fontsize=11, fontweight='bold')

ax5.set_xlabel('Importância da Feature', fontsize=14)
ax5.set_title('Importância dos Atributos na Classificação de Acessibilidade\n(Árvore de Decisão)', 
             fontsize=18, fontweight='bold', pad=20)
ax5.grid(axis='x', alpha=0.3)

# Destacar a feature mais importante
bars[0].set_color('#F18F01')
bars[0].set_edgecolor('black')
bars[0].set_linewidth(2)

plt.tight_layout()
plt.show()

# ============================================
# 7. GRÁFICO 6: DISTRIBUIÇÃO POR REGIÃO/IDADE/GÊNERO
# ============================================

fig6 = make_subplots(
    rows=2, cols=2,
    subplot_titles=('Distribuição por Idade', 'Distribuição por Gênero',
                   'Distribuição por Raça/Cor', 'Distribuição por Região'),
    specs=[[{'type': 'histogram'}, {'type': 'pie'}],
          [{'type': 'bar'}, {'type': 'bar'}]]
)

# Dados simulados
idades = np.random.normal(25, 8, 10000)
idades = idades[(idades >= 15) & (idades <= 70)]
genero = ['Masculino'] * 5200 + ['Feminino'] * 4800
raca = ['Branca'] * 4500 + ['Parda'] * 4000 + ['Preta'] * 1200 + ['Amarela'] * 200 + ['Indígena'] * 100
regioes = ['Nordeste'] * 3500 + ['Sudeste'] * 3000 + ['Sul'] * 1500 + ['Norte'] * 1200 + ['Centro-Oeste'] * 800

# Gráfico 1: Histograma de idades
fig6.add_trace(
    go.Histogram(x=idades, nbinsx=20, name='Idade',
                marker_color='#2E86AB', opacity=0.7),
    row=1, col=1
)

# Gráfico 2: Pizza de gênero
genero_counts = pd.Series(genero).value_counts()
fig6.add_trace(
    go.Pie(labels=genero_counts.index, values=genero_counts.values,
          marker=dict(colors=['#A23B72', '#2E86AB']), name='Gênero'),
    row=1, col=2
)

# Gráfico 3: Barras de raça
raca_counts = pd.Series(raca).value_counts()
fig6.add_trace(
    go.Bar(x=raca_counts.index, y=raca_counts.values, name='Raça/Cor',
          marker_color='#73AB84'),
    row=2, col=1
)

# Gráfico 4: Barras de região
regiao_counts = pd.Series(regioes).value_counts()
fig6.add_trace(
    go.Bar(x=regiao_counts.index, y=regiao_counts.values, name='Região',
          marker_color='#F18F01'),
    row=2, col=2
)

# Atualizar layout
fig6.update_layout(
    title_text='Perfil Demográfico dos Alunos com Deficiência no Ensino Superior',
    title_font_size=20,
    title_font_weight='bold',
    showlegend=False,
    height=800
)

fig6.update_xaxes(title_text='Idade', row=1, col=1)
fig6.update_yaxes(title_text='Frequência', row=1, col=1)
fig6.update_xaxes(title_text='Raça/Cor', row=2, col=1)
fig6.update_yaxes(title_text='Número de Alunos', row=2, col=1)
fig6.update_xaxes(title_text='Região', row=2, col=2)
fig6.update_yaxes(title_text='Número de Alunos', row=2, col=2)

fig6.show()

# ============================================
# 8. GRÁFICO 7: COMPARAÇÃO POPULAÇÃO TOTAL vs ENSINO SUPERIOR
# ============================================

fig7, ax7 = plt.subplots(1, 2, figsize=(16, 7))

# Dados simulados
categorias = ['Deficiência Visual', 'Deficiência Auditiva', 
              'Deficiência Física', 'Deficiência Cognitiva',
              'Deficiência Múltipla']

# Percentual na população geral (simulado)
percentual_populacao = [3.5, 2.8, 2.5, 1.5, 0.7]

# Percentual no ensino superior (simulado)
percentual_ensino_superior = [18, 20, 25, 15, 8]

x = np.arange(len(categorias))
width = 0.35

# Gráfico 1: Comparação lado a lado
bars1 = ax7[0].bar(x - width/2, percentual_populacao, width, 
                  label='População Geral (%)', color='#2E86AB')
bars2 = ax7[0].bar(x + width/2, percentual_ensino_superior, width, 
                  label='Ensino Superior (%)', color='#F18F01')

ax7[0].set_xlabel('Tipo de Deficiência', fontsize=14)
ax7[0].set_ylabel('Percentual (%)', fontsize=14)
ax7[0].set_title('Comparação: População Geral vs Ensino Superior', 
                fontsize=16, fontweight='bold', pad=20)
ax7[0].set_xticks(x)
ax7[0].set_xticklabels(categorias, rotation=45, ha='right')
ax7[0].legend(fontsize=12)
ax7[0].grid(axis='y', alpha=0.3)

# Adicionar valores nas barras
for bars in [bars1, bars2]:
    for bar in bars:
        height = bar.get_height()
        ax7[0].text(bar.get_x() + bar.get_width()/2., height + 0.5,
                   f'{height}%', ha='center', va='bottom', fontsize=10)

# Gráfico 2: Razão ES/População
razao = np.array(percentual_ensino_superior) / np.array(percentual_populacao)
bars3 = ax7[1].bar(categorias, razao, color=['#73AB84' if r < 1 else '#C14953' for r in razao])
ax7[1].axhline(y=1, color='red', linestyle='--', alpha=0.5, label='Linha de Igualdade (1:1)')
ax7[1].set_xlabel('Tipo de Deficiência', fontsize=14)
ax7[1].set_ylabel('Razão (ES / População Geral)', fontsize=14)
ax7[1].set_title('Razão de Representatividade no Ensino Superior', 
                fontsize=16, fontweight='bold', pad=20)
ax7[1].set_xticklabels(categorias, rotation=45, ha='right')
ax7[1].legend(fontsize=12)
ax7[1].grid(axis='y', alpha=0.3)

# Adicionar valores nas barras
for bar, r in zip(bars3, razao):
    height = bar.get_height()
    ax7[1].text(bar.get_x() + bar.get_width()/2., height + 0.05,
               f'{r:.1f}x', ha='center', va='bottom', fontsize=11, fontweight='bold')

plt.tight_layout()
plt.show()

# ============================================
# 9. RESUMO ESTATÍSTICO
# ============================================

print("="*80)
print("RESUMO ESTATÍSTICO - ANÁLISE DE PCD NO ENSINO SUPERIOR")
print("="*80)

print("\n1. EVOLUÇÃO TEMPORAL (2011-2019):")
print(f"   • Alunos PCD em 2011: {alunos_pcd[0]:,}".replace(',', '.'))
print(f"   • Alunos PCD em 2019: {alunos_pcd[-1]:,}".replace(',', '.'))
print(f"   • Crescimento 2011-2019: {((alunos_pcd[-1]-alunos_pcd[0])/alunos_pcd[0]*100):.1f}%")
print(f"   • Percentual no total (2019): {df_evolucao['Percentual_PCD'].iloc[-1]:.3f}%")

print("\n2. PROJEÇÃO PARA 2030:")
print(f"   • Alunos PCD projetados: {projecao[-1]:,.0f}".replace(',', '.'))
print(f"   • Crescimento 2019-2030: {crescimento_percentual:.1f}%")
print(f"   • Coeficiente de determinação (R²): {r2:.3f}")

print("\n3. DISTRIBUIÇÃO POR TIPO DE DEFICIÊNCIA (2019):")
for tipo, perc in zip(tipos_deficiencia[:5], percentuais[:5]):
    print(f"   • {tipo}: {perc}%")

print("\n4. CLUSTERING DE IES (3 grupos identificados):")
for cluster_num, cluster_name in cluster_names.items():
    count = (df_ies['Cluster'] == cluster_num).sum()
    perc = (count / len(df_ies)) * 100
    print(f"   • {cluster_name}: {count} IES ({perc:.1f}%)")

print("\n5. IMPORTÂNCIA DE ATRIBUTOS (Árvore de Decisão):")
for idx in indices[:3]:
    print(f"   • {features[idx]}: {importancias[idx]:.3f}")

print("\n" + "="*80)
print("CONCLUSÕES PRINCIPAIS:")
print("="*80)
print("1. Crescimento significativo, mas ainda abaixo do percentual populacional")
print("2. Distribuição desigual de recursos entre IES")
print("3. Dados binários limitam análise quantitativa")
print("4. Necessidade de políticas específicas por tipo de deficiência")
print("="*80)

# ============================================
# 10. EXPORTAR GRÁFICOS PARA ARQUIVOS
# ============================================

print("\nExportando gráficos para arquivos PNG...")

# Criar diretório para salvar gráficos
import os
os.makedirs('graficos_pcd', exist_ok=True)

# Salvar cada gráfico
fig1.savefig('graficos_pcd/01_evolucao_temporal.png', dpi=300, bbox_inches='tight')
fig2.savefig('graficos_pcd/02_projecao_2030.png', dpi=300, bbox_inches='tight')
fig3.savefig('graficos_pcd/03_tipos_deficiencia.png', dpi=300, bbox_inches='tight')
fig4.savefig('graficos_pcd/04_clustering_ies.png', dpi=300, bbox_inches='tight')
fig5.savefig('graficos_pcd/05_importancia_atributos.png', dpi=300, bbox_inches='tight')
fig6.write_image('graficos_pcd/06_perfil_demografico.png', width=1200, height=800)
fig7.savefig('graficos_pcd/07_comparacao_populacao.png', dpi=300, bbox_inches='tight')

print("Gráficos exportados com sucesso na pasta 'graficos_pcd/'!")
print("\nPróximos passos:")
print("1. Carregar dados reais do INEP (Microdados do Censo)")
print("2. Ajustar parâmetros dos modelos com dados reais")
print("3. Realizar análise estatística inferencial")
print("4. Desenvolver dashboard interativo")